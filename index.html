<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Cony Terminal</title>
    <style>
        body {
            background-color: #0000AA; 
            color: #FFFFFF;
            font-family: 'Courier New', Courier, monospace; 
            font-size: 18px; 
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        #message-container {
            width: 100%;
            position: relative;
            z-index: 10;
        }

        .line {
            line-height: 1.5;
            white-space: pre; 
            margin: 0;
        }

        .bold {
            font-weight: bold;
        }

        .rabbit-dialog {
            font-weight: bold; 
        }

        .blinking-cursor {
            animation: blink 0.7s infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        .glitch-cursor {
            animation: glitch-blink 0.1s infinite step-end; 
        }

        @keyframes glitch-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* 아이콘 스타일 */
        .desktop-icon {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: background 0.2s;
            z-index: 100;
        }

        .desktop-icon:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .desktop-icon.selected {
            background: rgba(255, 255, 255, 0.2);
        }

        .desktop-icon img {
            width: 80px;
            height: 80px;
            object-fit: contain;
            margin-bottom: 8px;
            pointer-events: none;
        }

        .desktop-icon span {
            color: #FFFFFF;
            font-size: 14px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }
    </style>
</head>
<body id="terminal">
    <div id="message-container"></div>

    <!-- 아이콘들 -->
    <div class="desktop-icon" id="icon-youtube" style="bottom: 120px; left: 40px;">
        <img src="rabbit_youtube.png" alt="YouTube">
        <span>YouTube</span>
    </div>

    <div class="desktop-icon" id="icon-54" style="bottom: 120px; left: 160px;">
        <img src="Papers_54.png" alt="54">
        <span>54</span>
    </div>
    
    <script>
        const messageContainer = document.getElementById('message-container');
        
        const YOUTUBE_URL = "https://youtube.com/@conyca?si=t19YccJ7cFmYJE9X";
        const TIMELINE_URL = "https://6fpqxhvkv9-sudo.github.io/follow-the-white-rabbit/timeline.html";

        // 스크립트 배열 - pause 시간 대폭 줄임
        const script = [
            { text: "Hello. I am ", type: 'normal', pause: 0, line: 'new' }, 
            { text: "Dolores", type: 'bold', pause: 0, line: 'continue' },
            { text: ". I am the administrator of this page.", type: 'normal', pause: 300, line: 'continue' },
            { text: "This place will soon heal and renew your body and mind.", type: 'normal', pause: 300, line: 'new' }, 
            { text: "For a moment, escape all anxiety, pain, and emptiness, ", type: 'normal', pause: 500, line: 'new' }, 
            { text: "free your soul, and discover your true self...f981gh", type: 'glitch', pause: 0, line: 'continue', interrupt: true }, 
            { text: "Oh dear! Oh dear! I shall be too late!", type: 'rabbit', pause: 300, line: 'new' }, 
            { text: "Follow the white rabbit.", type: 'normal', pause: 0, line: 'new', final: true } 
        ];
        
        let scriptIndex = 0;
        let typingTimeout; 
        const defaultSpeed = 25;  // 더 빠르게
        const glitchSpeed = 15; 

        function typeLine(item, callback) {
            let line;
            
            if (item.line === 'new') {
                line = document.createElement('p');
                line.classList.add('line');
                if (item.type === 'rabbit') {
                    line.classList.add('rabbit-dialog');
                }
                messageContainer.appendChild(line);
                messageContainer.scrollTop = messageContainer.scrollHeight;
            } else {
                line = messageContainer.lastElementChild;
                if (!line) return callback();
                const prevCursor = line.querySelector('.blinking-cursor') || line.querySelector('.glitch-cursor');
                if (prevCursor) line.removeChild(prevCursor);
            }
            
            let textToType = item.text;
            let charIndex = 0;
            let currentSpeed = item.type === 'glitch' ? glitchSpeed : defaultSpeed;
            let glitch_triggered_1 = false; 
            let glitch_triggered_2 = false; 
            
            const cursorSpan = document.createElement('span');
            cursorSpan.classList.add('blinking-cursor');
            cursorSpan.textContent = '_';
            line.appendChild(cursorSpan);

            function typeChar() {
                if (item.type === 'glitch' && charIndex < textToType.length) {
                    const currentString = textToType.substring(0, charIndex + 1);
                    
                    if (currentString.includes("free") && !glitch_triggered_1) {
                        glitch_triggered_1 = true;
                        cursorSpan.classList.add('glitch-cursor');
                        cursorSpan.classList.remove('blinking-cursor');
                        simulateTypingGlitch(line, cursorSpan, 4, () => {
                            typeChar(); 
                        });
                        return;
                    } 
                    
                    if (currentString.includes("your") && !glitch_triggered_2) {
                        glitch_triggered_2 = true;
                        cursorSpan.classList.add('glitch-cursor');
                        cursorSpan.classList.remove('blinking-cursor');
                        simulateTypingGlitch(line, cursorSpan, 4, () => { 
                            typeChar(); 
                        });
                        return;
                    }
                }
                
                if (charIndex < textToType.length) {
                    const char = textToType.charAt(charIndex);
                    
                    if (item.type === 'bold') {
                        let boldSpan = line.querySelector('.bold');
                        if (!boldSpan) {
                            boldSpan = document.createElement('span');
                            boldSpan.classList.add('bold');
                            line.insertBefore(boldSpan, cursorSpan);
                        }
                        boldSpan.appendChild(document.createTextNode(char));
                    } else {
                        line.insertBefore(document.createTextNode(char), cursorSpan);
                    }
                    
                    charIndex++;
                    typingTimeout = setTimeout(typeChar, currentSpeed);

                } else {
                    clearTimeout(typingTimeout); 

                    if (item.final) {
                        handleFinalSequence(line, cursorSpan);
                    } else {
                        setTimeout(() => {
                            line.removeChild(cursorSpan);
                            callback(); 
                        }, item.pause);
                    }
                }
            }
            typeChar();
        }

        function simulateTypingGlitch(lineElement, cursorElement, maxGlitch, callback) {
            const glitchChars = "~!@#$%^&0123456789";
            let glitchCount = 0;
            const glitchInterval = 30; 

            function glitchStep() {
                if (glitchCount < maxGlitch) {
                    if (glitchCount % 2 === 0) {
                        const randomChar = glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        lineElement.insertBefore(document.createTextNode(randomChar), cursorElement);
                    } else {
                        const lastChild = lineElement.childNodes[lineElement.childNodes.length - 2];
                        if (lastChild && lastChild !== cursorElement) { 
                            lineElement.removeChild(lastChild);
                        }
                    }
                    glitchCount++;
                    setTimeout(glitchStep, glitchInterval);
                } else {
                    cursorElement.classList.remove('glitch-cursor');
                    cursorElement.classList.add('blinking-cursor');
                    callback(); 
                }
            }
            glitchStep();
        }

        function handleFinalSequence(lineElement, cursorSpan) {
            const y_n_html = ' <span id="choice-y" style="cursor: pointer; margin-right: 20px;">y</span> / <span id="choice-n" style="cursor: pointer;">n</span>';
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = y_n_html;
            
            while (tempDiv.firstChild) {
                lineElement.insertBefore(tempDiv.firstChild, cursorSpan);
            }
            
            document.getElementById('choice-y').addEventListener('click', () => {
                window.open(YOUTUBE_URL, '_blank');
            });
            
            document.getElementById('choice-n').addEventListener('click', (e) => {
                const choiceLine = e.target.closest('.line');
                const y_n_text = choiceLine.textContent;
                const cleanedText = y_n_text.substring(0, y_n_text.lastIndexOf('y / n')) + 'n';
                choiceLine.innerHTML = cleanedText;
            });
        }

        function runScript() {
            if (scriptIndex < script.length) {
                const item = script[scriptIndex];
                scriptIndex++;
                typeLine(item, runScript);
            }
        }

        // === 드래그 가능한 아이콘 ===
        const icons = document.querySelectorAll('.desktop-icon');
        
        icons.forEach(icon => {
            let isDragging = false;
            let hasMoved = false;
            let offsetX, offsetY;
            let startX, startY;

            icon.addEventListener('mousedown', (e) => {
                isDragging = true;
                hasMoved = false;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = icon.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                icon.classList.add('selected');
                icon.style.zIndex = 1000;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const moveX = Math.abs(e.clientX - startX);
                const moveY = Math.abs(e.clientY - startY);
                
                if (moveX > 5 || moveY > 5) {
                    hasMoved = true;
                }
                
                icon.style.left = (e.clientX - offsetX) + 'px';
                icon.style.top = (e.clientY - offsetY) + 'px';
                icon.style.bottom = 'auto';
                icon.style.right = 'auto';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    icon.style.zIndex = 100;
                }
            });

            // 더블클릭 → 링크 열기
            icon.addEventListener('dblclick', () => {
                if (!hasMoved) {
                    if (icon.id === 'icon-youtube') {
                        window.open(YOUTUBE_URL, '_blank');
                    } else if (icon.id === 'icon-54') {
                        window.open(TIMELINE_URL, '_blank');
                    }
                }
            });

            // 클릭 시 선택 효과
            icon.addEventListener('click', () => {
                icons.forEach(i => i.classList.remove('selected'));
                icon.classList.add('selected');
            });
        });

        // 바탕화면 클릭 시 선택 해제
        document.body.addEventListener('click', (e) => {
            if (e.target === document.body || e.target === document.getElementById('terminal')) {
                icons.forEach(i => i.classList.remove('selected'));
            }
        });

        document.addEventListener('DOMContentLoaded', runScript);
    </script>
</body>
</html>
